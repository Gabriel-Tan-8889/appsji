import SwiftUI
import Combine

// MARK: - Models

struct UserAccount: Codable, Equatable {
    var username: String
    var password: String
    var securityQuestion: String?
    var securityAnswer: String?
}

struct Flashcard: Codable, Identifiable {
    let id = UUID()
    var question: String
    var answer: String
}

struct Challenge: Codable, Identifiable {
    let id = UUID()
    var question: String
    var answer: String
    var attempted: Bool = false
}

struct ReminderItem: Codable, Identifiable {
    let id = UUID()
    var msg: String
    var dateString: String // "yyyy-MM-dd HH:mm"
}

// MARK: - App Model

final class StudyAppModel: ObservableObject {
    // Data containers
    @Published var accounts: [String: UserAccount] = [:]            // username -> account
    @Published var points: [String: Int] = [:]
    @Published var friends: [String: [String]] = [:]
    @Published var friendRequests: [String: [String]] = [:]
    @Published var flashcards: [String: [Flashcard]] = [:]
    @Published var dailyChallenges: [String: [Challenge]] = [:]
    @Published var calendarPlans: [String: [String: String]] = [:] // user -> date -> task
    @Published var rewards: [String: [String]] = [:]
    @Published var reminders: [String: [ReminderItem]] = [:]
    @Published var pastUsernames: [String] = []
    @Published var lastStudyTime: [String: Date] = [:]
    @Published var pomodoroConfig: [String: Int] = ["work": 25, "break": 5]

    @Published var currentUser: String? = nil
    @Published var loginError: String? = nil

    private let storageKey = "StudyAppModelStorage_v1"

    init() {
        load()
    }

    // MARK: - Persistence
    func save() {
        let wrapper = StorageWrapper(accounts: accounts,
                                     points: points,
                                     friends: friends,
                                     friendRequests: friendRequests,
                                     flashcards: flashcards,
                                     dailyChallenges: dailyChallenges,
                                     calendarPlans: calendarPlans,
                                     rewards: rewards,
                                     reminders: reminders,
                                     pastUsernames: pastUsernames,
                                     lastStudyTime: lastStudyTime.mapValues { $0.timeIntervalSince1970 },
                                     pomodoroConfig: pomodoroConfig)
        if let data = try? JSONEncoder().encode(wrapper) {
            UserDefaults.standard.set(data, forKey: storageKey)
        }
    }

    func load() {
        guard let data = UserDefaults.standard.data(forKey: storageKey),
              let wrapper = try? JSONDecoder().decode(StorageWrapper.self, from: data) else {
            // initialize empty structures
            return
        }
        self.accounts = wrapper.accounts
        self.points = wrapper.points
        self.friends = wrapper.friends
        self.friendRequests = wrapper.friendRequests
        self.flashcards = wrapper.flashcards.mapValues { $0 }
        self.dailyChallenges = wrapper.dailyChallenges.mapValues { $0 }
        self.calendarPlans = wrapper.calendarPlans
        self.rewards = wrapper.rewards
        self.reminders = wrapper.reminders.mapValues { $0 }
        self.pastUsernames = wrapper.pastUsernames
        self.lastStudyTime = wrapper.lastStudyTime.mapValues { Date(timeIntervalSince1970: $0) }
        self.pomodoroConfig = wrapper.pomodoroConfig
    }

    struct StorageWrapper: Codable {
        var accounts: [String: UserAccount]
        var points: [String: Int]
        var friends: [String: [String]]
        var friendRequests: [String: [String]]
        var flashcards: [String: [Flashcard]]
        var dailyChallenges: [String: [Challenge]]
        var calendarPlans: [String: [String: String]]
        var rewards: [String: [String]]
        var reminders: [String: [ReminderItem]]
        var pastUsernames: [String]
        var lastStudyTime: [String: TimeInterval]
        var pomodoroConfig: [String: Int]
    }

    // MARK: - Helpers
    func ensureUser(_ username: String) {
        if points[username] == nil { points[username] = 0 }
        if friends[username] == nil { friends[username] = [] }
        if friendRequests[username] == nil { friendRequests[username] = [] }
        if flashcards[username] == nil { flashcards[username] = [] }
        if dailyChallenges[username] == nil { dailyChallenges[username] = [] }
        if calendarPlans[username] == nil { calendarPlans[username] = [:] }
        if rewards[username] == nil { rewards[username] = [] }
        if reminders[username] == nil { reminders[username] = [] }
        if pastUsernames.firstIndex(of: username) == nil {
            pastUsernames.append(username)
        }
    }

    // MARK: - Accounts
    func signUp(username: String, password: String, question: String?, answer: String?) -> Bool {
        guard accounts[username] == nil, !username.isEmpty, !password.isEmpty else { return false }
        let acc = UserAccount(username: username, password: password, securityQuestion: question, securityAnswer: answer)
        accounts[username] = acc
        ensureUser(username)
        save()
        return true
    }

    func login(username: String, password: String) -> Bool {
        ensureUser(username)
        pastUsernames = Array(Set(pastUsernames + [username]))
        if let acc = accounts[username], acc.password == password {
            currentUser = username
            loginError = nil
            save()
            return true
        } else {
            loginError = "Invalid credentials"
            return false
        }
    }

    func resetPassword(username: String, providedAnswer: String, newPassword: String) -> Bool {
        guard var acc = accounts[username],
              let correct = acc.securityAnswer, !correct.isEmpty else { return false }
        if correct.lowercased() == providedAnswer.trimmingCharacters(in: .whitespacesAndNewlines).lowercased() {
            acc.password = newPassword
            accounts[username] = acc
            save()
            return true
        }
        return false
    }

    func logout() {
        currentUser = nil
        save()
    }

    // MARK: - Friend requests / friends
    func sendFriendRequest(to username: String) {
        guard let me = currentUser, username != me, accounts[username] != nil else { return }
        ensureUser(username)
        if !(friendRequests[username]?.contains(me) ?? false), !(friends[username]?.contains(me) ?? false) {
            friendRequests[username]?.append(me)
            save()
        }
    }

    func acceptFriendRequest(from username: String) {
        guard let me = currentUser else { return }
        if friendRequests[me]?.contains(username) ?? false {
            friends[me, default: []].append(username)
            friends[username, default: []].append(me)
            friendRequests[me]?.removeAll(where: { $0 == username })
            save()
        }
    }

    // MARK: - Study / points
    func studyHour() {
        guard let me = currentUser else { return }
        points[me, default: 0] += 2
        save()
    }

    func grantStudyPoints(durationMinutes: Int) -> String {
        guard let me = currentUser else { return "No user" }
        // prevent cheating: 10 min cooldown
        if let last = lastStudyTime[me], Date().timeIntervalSince(last) < 10 * 60 {
            return "Wait at least 10 minutes between point-earning sessions."
        }
        let pts = max(1, (durationMinutes / 25) * 2)
        points[me, default: 0] += pts
        lastStudyTime[me] = Date()
        save()
        return "Awarded \(pts) pts."
    }

    // MARK: - Flashcards
    func createFlashcard(question: String, answer: String) {
        guard let me = currentUser else { return }
        flashcards[me, default: []].append(Flashcard(question: question, answer: answer))
        save()
    }

    func studyFlashcards(assignDifficultyPoints: (String) -> Int) -> Int {
        guard let me = currentUser else { return 0 }
        var awarded = 0
        for card in flashcards[me, default: []] {
            let pts = assignDifficultyPoints("medium") // UI should ask; here default medium
            points[me, default: 0] += pts
            awarded += pts
        }
        save()
        return awarded
    }

    // MARK: - Planner
    func addPlan(date: String, subject: String, today: Bool) {
        guard let me = currentUser else { return }
        calendarPlans[me, default: [:]][date] = subject
        if today { points[me, default: 0] += 1 }
        save()
    }

    // MARK: - Challenges
    func createChallenge(question: String, answer: String) {
        guard let me = currentUser else { return }
        dailyChallenges[me, default: []].append(Challenge(question: question, answer: answer))
        save()
    }

    func answerChallenge(challengeId: UUID, response: String) -> Bool {
        guard let me = currentUser else { return false }
        guard var list = dailyChallenges[me] else { return false }
        if let idx = list.firstIndex(where: { $0.id == challengeId }) {
            if list[idx].attempted { return false }
            if list[idx].answer.trimmingCharacters(in: .whitespacesAndNewlines).lowercased() == response.trimmingCharacters(in: .whitespacesAndNewlines).lowercased() {
                points[me, default: 0] += 1
                list[idx].attempted = true
                dailyChallenges[me] = list
                save()
                return true
            } else {
                list[idx].attempted = true
                dailyChallenges[me] = list
                save()
                return false
            }
        }
        return false
    }

    // MARK: - Reminders
    func setReminder(msg: String, dateString: String) {
        guard let me = currentUser else { return }
        reminders[me, default: []].append(ReminderItem(msg: msg, dateString: dateString))
        save()
    }

    func checkDueReminders() -> [ReminderItem] {
        var due: [ReminderItem] = []
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm"
        for (user, rems) in reminders {
            for r in rems {
                if let d = formatter.date(from: r.dateString), d <= Date() {
                    due.append(r)
                }
            }
        }
        // remove delivered
        for (user, rems) in reminders {
            reminders[user] = rems.filter {
                if let d = formatter.date(from: $0.dateString) { return d > Date() }
                return true
            }
        }
        save()
        return due
    }

    // MARK: - Leaderboard
    func leaderboard() -> [(String, Int)] {
        guard let me = currentUser else { return [] }
        let friendsAndMe = [me] + (friends[me] ?? [])
        var map: [String: Int] = [:]
        for u in Set(friendsAndMe) {
            map[u] = points[u, default: 0]
        }
        return map.sorted { $0.value > $1.value }
    }

    // MARK: - Rewards
    func availableToRedeem() -> Bool {
        guard let me = currentUser else { return false }
        return points[me, default: 0] >= 10
    }

    func redeemReward(choice: Int) -> String {
        guard let me = currentUser else { return "No user" }
        let map = [
            1: "Gift card",
            2: "Game prop",
            3: "Extra theme",
            4: "Pet",
            5: "Extra content",
            6: "Keep points"
        ]
        let reward = map[choice] ?? "Gift card"
        if choice == 6 {
            return "Kept points"
        } else {
            if points[me, default: 0] >= 10 {
                rewards[me, default: []].append(reward)
                points[me, default: 0] -= 10
                save()
                return "Redeemed \(reward)"
            } else {
                return "Not enough points"
            }
        }
    }
}

// MARK: - SwiftUI Views (simple)
// NOTE: These are intentionally simple UIs for demonstration. You can extend styling and behavior.

struct ContentView: View {
    @StateObject var model = StudyAppModel()

    var body: some View {
        if model.currentUser == nil {
            LoginView(model: model)
        } else {
            MainMenuView(model: model)
        }
    }
}

struct LoginView: View {
    @ObservedObject var model: StudyAppModel
    @State private var username = ""
    @State private var password = ""
    @State private var showSignUp = false

    var body: some View {
        VStack(spacing: 12) {
            Text(showSignUp ? "Sign Up" : "Login").font(.largeTitle)
            TextField("Username", text: $username).textFieldStyle(RoundedBorderTextFieldStyle())
            SecureField("Password", text: $password).textFieldStyle(RoundedBorderTextFieldStyle())

            if let err = model.loginError { Text(err).foregroundColor(.red) }

            Button(showSignUp ? "Create Account" : "Login") {
                if showSignUp {
                    // For simplicity, ask for security Q/ans via alert style in a real app; here we set blank
                    let created = model.signUp(username: username, password: password, question: nil, answer: nil)
                    if created {
                        _ = model.login(username: username, password: password)
                    } else {
                        model.loginError = "Username exists or invalid."
                    }
                } else {
                    _ = model.login(username: username, password: password)
                }
            }.padding()

            Button(showSignUp ? "Have account? Login" : "No account? Sign Up") {
                showSignUp.toggle()
            }
        }
        .padding()
    }
}

struct MainMenuView: View {
    @ObservedObject var model: StudyAppModel
    @State private var friendName = ""
    @State private var showRewards = false
    @State private var showTimer = false
    @State private var showFlashcards = false
    @State private var showPlanner = false
    @State private var showChallenges = false
    @State private var showLeaderboard = false
    @State private var showReminders: [ReminderItem] = []

    var body: some View {
        VStack(spacing: 12) {
            if let user = model.currentUser {
                Text("Hello, \(user)! Points: \(model.points[user, default: 0])").font(.headline)

                if let pending = model.friendRequests[user], !pending.isEmpty {
                    VStack(alignment: .leading) {
                        Text("Friend requests:").bold()
                        ForEach(pending, id: \.self) { req in
                            HStack {
                                Text(req)
                                Spacer()
                                Button("Accept") {
                                    model.acceptFriendRequest(from: req)
                                }
                            }
                        }
                    }.padding()
                }

                HStack {
                    TextField("Friend's username", text: $friendName).textFieldStyle(RoundedBorderTextFieldStyle())
                    Button("Add") {
                        model.sendFriendRequest(to: friendName)
                        friendName = ""
                    }
                }

                HStack {
                    Button("Study +2") { model.studyHour() }
                    Button("Timer") { showTimer = true }
                }

                HStack {
                    Button("Flashcards") { showFlashcards = true }
                    Button("Planner") { showPlanner = true }
                    Button("Challenges") { showChallenges = true }
                }

                HStack {
                    Button("Leaderboard") { showLeaderboard = true }
                    Button("Rewards") { showRewards = true }
                    Button("Logout") { model.logout() }
                }

                Spacer()
            }
        }
        .padding()
        // Sheets/presentations
        .sheet(isPresented: $showRewards) { RewardSheetView(model: model) }
        .sheet(isPresented: $showTimer) { TimerView(model: model) }
        .sheet(isPresented: $showFlashcards) { FlashcardsView(model: model) }
        .sheet(isPresented: $showPlanner) { PlannerView(model: model) }
        .sheet(isPresented: $showChallenges) { ChallengesView(model: model) }
        .sheet(isPresented: $showLeaderboard) { LeaderboardView(model: model) }
    }
}

// Simple flashcards view
struct FlashcardsView: View {
    @ObservedObject var model: StudyAppModel
    @State private var question = ""
    @State private var answer = ""

    var body: some View {
        NavigationView {
            VStack {
                Form {
                    Section(header: Text("Create")) {
                        TextField("Question", text: $question)
                        TextField("Answer", text: $answer)
                        Button("Add") {
                            model.createFlashcard(question: question, answer: answer)
                            question = ""; answer = ""
                        }
                    }
                    Section(header: Text("Your flashcards")) {
                        List {
                            if let user = model.currentUser {
                                ForEach(model.flashcards[user] ?? []) { card in
                                    VStack(alignment: .leading) {
                                        Text(card.question).bold()
                                        Text(card.answer).foregroundColor(.secondary)
                                    }
                                }
                            }
                        }
                    }
                }
            }
            .navigationTitle("Flashcards")
            .toolbar { ToolbarItem(placement: .cancellationAction) { Button("Close") { UIApplication.shared.windows.first?.rootViewController?.dismiss(animated: true) } } }
        }
    }
}

struct PlannerView: View {
    @ObservedObject var model: StudyAppModel
    @State private var date = ""
    @State private var subject = ""
    @State private var today = false

    var body: some View {
        NavigationView {
            Form {
                TextField("YYYY-MM-DD", text: $date)
                TextField("Subject/Task", text: $subject)
                Toggle("Is today?", isOn: $today)
                Button("Add Plan") {
                    model.addPlan(date: date, subject: subject, today: today)
                    date = ""; subject = ""; today = false
                }
                if let me = model.currentUser {
                    Section("Your plans") {
                        ForEach(Array(model.calendarPlans[me]?.sorted(by: { $0.key < $1.key }) ?? []), id: \.key) { k, v in
                            HStack {
                                Text(k); Spacer(); Text(v)
                            }
                        }
                    }
                }
            }
            .navigationTitle("Planner")
            .toolbar { ToolbarItem(placement: .cancellationAction) { Button("Close") { UIApplication.shared.windows.first?.rootViewController?.dismiss(animated: true) } } }
        }
    }
}

struct ChallengesView: View {
    @ObservedObject var model: StudyAppModel
    @State private var question = ""
    @State private var answer = ""
    @State private var response = ""

    var body: some View {
        NavigationView {
            VStack {
                Form {
                    Section(header: Text("Create Challenge")) {
                        TextField("Question", text: $question)
                        TextField("Answer", text: $answer)
                        Button("Create") {
                            model.createChallenge(question: question, answer: answer)
                            question = ""; answer = ""
                        }
                    }
                    if let me = model.currentUser {
                        Section(header: Text("Pending")) {
                            List {
                                ForEach(model.dailyChallenges[me] ?? []) { ch in
                                    VStack(alignment: .leading) {
                                        Text(ch.question).bold()
                                        HStack {
                                            TextField("Your answer", text: $response)
                                            Button("Submit") {
                                                let ok = model.answerChallenge(challengeId: ch.id, response: response)
                                                response = ""
                                                // optionally show feedback
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            .navigationTitle("Challenges")
            .toolbar { ToolbarItem(placement: .cancellationAction) { Button("Close") { UIApplication.shared.windows.first?.rootViewController?.dismiss(animated: true) } } }
        }
    }
}

struct TimerView: View {
    @ObservedObject var model: StudyAppModel
    @State private var workMinutes = 25
    @State private var breakMinutes = 5
    @State private var customMinutes = 10
    @State private var message = ""

    var body: some View {
        NavigationView {
            VStack(spacing: 12) {
                HStack {
                    Stepper("Work: \(workMinutes)m", value: $workMinutes, in: 1...120)
                    Stepper("Break: \(breakMinutes)m", value: $breakMinutes, in: 1...60)
                }
                Button("Start Pomodoro (simulate)") {
                    // we won't block UI; simulate awarding points for work
                    message = model.grantStudyPoints(durationMinutes: workMinutes)
                }
                Divider()
                HStack {
                    Stepper("Custom: \(customMinutes)m", value: $customMinutes, in: 1...600)
                    Button("Start Custom") { message = model.grantStudyPoints(durationMinutes: customMinutes) }
                }
                Text(message).padding()
                Spacer()
            }
            .padding()
            .navigationTitle("Timer")
            .toolbar { ToolbarItem(placement: .cancellationAction) { Button("Close") { UIApplication.shared.windows.first?.rootViewController?.dismiss(animated: true) } } }
        }
    }
}

struct LeaderboardView: View {
    @ObservedObject var model: StudyAppModel

    var body: some View {
        NavigationView {
            VStack {
                List {
                    ForEach(model.leaderboard(), id: \.0) { name, pts in
                        HStack {
                            Text(name)
                            Spacer()
                            Text("\(pts) pts")
                            if name == model.currentUser { Text("(You)").italic() }
                        }
                    }
                }
            }
            .navigationTitle("Leaderboard")
            .toolbar { ToolbarItem(placement: .cancellationAction) { Button("Close") { UIApplication.shared.windows.first?.rootViewController?.dismiss(animated: true) } } }
        }
    }
}

struct RewardSheetView: View {
    @ObservedObject var model: StudyAppModel
    @Environment(\.presentationMode) var presentationMode
    var body: some View {
        NavigationView {
            VStack(spacing: 12) {
                Text("Rewards (10 pts)").font(.headline)
                ForEach(1..<7) { i in
                    Button(action: {
                        let msg = model.redeemReward(choice: i)
                        print(msg)
                        presentationMode.wrappedValue.dismiss()
                    }) {
                        Text(rewardName(i))
                    }
                    .disabled(i != 6 && !model.availableToRedeem())
                }
                Spacer()
            }
            .padding()
            .navigationTitle("Rewards")
            .toolbar { ToolbarItem(placement: .cancellationAction) { Button("Close") { presentationMode.wrappedValue.dismiss() } } }
        }
    }

    func rewardName(_ i: Int) -> String {
        switch i {
        case 1: return "Gift card"
        case 2: return "Game prop"
        case 3: return "Extra theme"
        case 4: return "Pet"
        case 5: return "Extra content"
        default: return "Keep points"
        }
    }
}

// MARK: - App entry

@main
struct StudyAppSwiftUI: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
