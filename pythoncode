import time
import json
import os
from datetime import datetime, timedelta

class StudyApp:
    def __init__(self):
        self.data_file = "studyapp_data.json"
        self.load_data()
        self.last_study_time = {}
        self.pomodoro_config = {"work": 25, "break": 5}
        self.study_history = {}
        self.flashcard_stats = {}
        self.user_type = {}
        self.child_accounts = {}
        self.teacher_students = {}
        self.time_limits = {}
        self.group_challenges = {}
        self.study_materials = {}
        self.notifications = {}
        self.study_assignments = {}  # NEW: Store teacher study time assignments

    def load_data(self):
        if os.path.exists(self.data_file):
            with open(self.data_file, "r") as f:
                data = json.load(f)
                self.accounts = data.get("accounts", {})
                self.security_questions = data.get("security_questions", {})
                self.failed_attempts = data.get("failed_attempts", {})
                self.locks = data.get("locks", {})
                self.points = data.get("points", {})
                self.friends = data.get("friends", {})
                self.flashcards = data.get("flashcards", {})
                self.daily_challenges = data.get("daily_challenges", {})
                self.calendar = data.get("calendar", {})
                self.rewards = data.get("rewards", {})
                self.past_usernames = data.get("past_usernames", [])
                self.friend_requests = data.get("friend_requests", {})
                self.reminders = data.get("reminders", {})
                self.study_history = data.get("study_history", {})
                self.flashcard_stats = data.get("flashcard_stats", {})
                self.user_type = data.get("user_type", {})
                self.child_accounts = data.get("child_accounts", {})
                self.teacher_students = data.get("teacher_students", {})
                self.time_limits = data.get("time_limits", {})
                self.group_challenges = data.get("group_challenges", {})
                self.study_materials = data.get("study_materials", {})
                self.notifications = data.get("notifications", {})
                self.study_assignments = data.get("study_assignments", {})  # NEW
        else:
            self.accounts = {}
            self.security_questions = {}
            self.failed_attempts = {}
            self.locks = {}
            self.points = {}
            self.friends = {}
            self.flashcards = {}
            self.daily_challenges = {}
            self.calendar = {}
            self.rewards = {}
            self.past_usernames = []
            self.friend_requests = {}
            self.reminders = {}
            self.study_history = {}
            self.flashcard_stats = {}
            self.user_type = {}
            self.child_accounts = {}
            self.teacher_students = {}
            self.time_limits = {}
            self.group_challenges = {}
            self.study_materials = {}
            self.notifications = {}
            self.study_assignments = {}  # NEW
        self.current_user = None

    def save_data(self):
        data = {
            "accounts": self.accounts,
            "security_questions": self.security_questions,
            "failed_attempts": self.failed_attempts,
            "locks": self.locks,
            "points": self.points,
            "friends": self.friends,
            "flashcards": self.flashcards,
            "daily_challenges": self.daily_challenges,
            "calendar": self.calendar,
            "rewards": self.rewards,
            "past_usernames": self.past_usernames,
            "friend_requests": self.friend_requests,
            "reminders": self.reminders,
            "study_history": self.study_history,
            "flashcard_stats": self.flashcard_stats,
            "user_type": self.user_type,
            "child_accounts": self.child_accounts,
            "teacher_students": self.teacher_students,
            "time_limits": self.time_limits,
            "group_challenges": self.group_challenges,
            "study_materials": self.study_materials,
            "notifications": self.notifications,
            "study_assignments": self.study_assignments,  # NEW
        }
        with open(self.data_file, "w") as f:
            json.dump(data, f)

    def ensure_user(self, username):
        # Always preserve type if already set
        if username not in self.user_type:
            self.user_type[username] = "student"
        if username not in self.points:
            self.points[username] = 0
        if username not in self.friends:
            self.friends[username] = []
        if username not in self.flashcards:
            self.flashcards[username] = []
        if username not in self.daily_challenges:
            self.daily_challenges[username] = []
        if username not in self.calendar:
            self.calendar[username] = {}
        if username not in self.rewards:
            self.rewards[username] = []
        if username not in self.failed_attempts:
            self.failed_attempts[username] = 0
        if username not in self.locks:
            self.locks[username] = 0
        if username not in self.friend_requests:
            self.friend_requests[username] = []
        if username not in self.reminders:
            self.reminders[username] = []
        if username not in self.study_history:
            self.study_history[username] = []
        if username not in self.flashcard_stats:
            self.flashcard_stats[username] = {"correct": 0, "total": 0}
        if username not in self.time_limits:
            self.time_limits[username] = 1440
        if username not in self.study_materials:
            self.study_materials[username] = []
        if username not in self.notifications:
            self.notifications[username] = []
        if username not in self.study_assignments:  # NEW
            self.study_assignments[username] = []
        if username not in self.child_accounts and self.user_type[username] == "parent":
            self.child_accounts[username] = []
        if username not in self.teacher_students and self.user_type[username] == "teacher":
            self.teacher_students[username] = []

    def start_screen(self):
        print("Welcome to Study App!")
        self.check_due_reminders()
        self.check_due_notifications()
        while True:
            self.login_flow()

    def login_flow(self):
        if self.past_usernames:
            print("\nPreviously used usernames:")
            for i, uname in enumerate(self.past_usernames, 1):
                print(f"{i}. {uname}")
        username = input("Enter username: ")
        if username not in self.past_usernames:
            self.past_usernames.append(username)
        self.ensure_user(username)
        if self.locks[username] > 0:
            print(f"Account locked. Please wait {self.locks[username]} seconds.")
            time.sleep(self.locks[username])
            self.locks[username] = 0
        password = input("Enter password: ")
        if self.check_credentials(username, password):
            self.current_user = username
            print("Login successful!")
            self.check_friend_requests(username)
            self.check_due_reminders()
            self.check_due_notifications()
            self.check_study_assignments()  # NEW: Check assignments on login
            self.loading_screen()
        else:
            print("Incorrect credentials.")
            self.failed_attempts[username] += 1
            if input("Forgot password? (y/n): ").lower() == "y":
                self.reset_password(username)
            elif username not in self.accounts:
                if input("No account! Sign up? (y/n): ").lower() == "y":
                    self.sign_up(username)
                self.save_data()
                return
            elif self.failed_attempts[username] >= 3:
                print("Locked out for 5 seconds.")
                self.locks[username] = 5
                self.failed_attempts[username] = 0
                time.sleep(5)
                self.locks[username] = 0
            self.save_data()
            return
        self.save_data()

    # NEW METHOD: Check study assignments on login
    def check_study_assignments(self):
        assignments = self.study_assignments.get(self.current_user, [])
        active_assignments = [a for a in assignments if not a.get('completed', False)]

        if active_assignments:
            print(f"\n📚 You have {len(active_assignments)} active study assignment(s):")
            for i, assignment in enumerate(active_assignments, 1):
                completed_time = assignment.get('completed_minutes', 0)
                remaining_time = assignment['total_minutes'] - completed_time
                due_date = assignment.get('due_date', 'No due date')

                print(f"{i}. Subject: {assignment['subject']}")
                print(f"   Total required: {assignment['total_minutes']} minutes")
                print(f"   Completed: {completed_time} minutes")
                print(f"   Remaining: {remaining_time} minutes")
                print(f"   Due: {due_date}")
                print(f"   From teacher: {assignment['teacher']}")

                # Show progress bar
                progress = (completed_time / assignment['total_minutes']) * 100
                progress_bar = "█" * int(progress // 5) + "░" * (20 - int(progress // 5))
                print(f"   Progress: [{progress_bar}] {progress:.1f}%")
                print()

    def check_friend_requests(self, username):
        pending = self.friend_requests[username]
        if pending:
            print("\nYou have friend requests from:")
            for requester in pending:
                print(f"- {requester}")
            to_accept = input("Enter usernames to accept (comma-separated, or blank to ignore): ")
            accepted = [u.strip() for u in to_accept.split(',') if u.strip()]
            for req in accepted:
                if req in pending:
                    if req not in self.friends[username]:
                        self.friends[username].append(req)
                    if username not in self.friends[req]:
                        self.friends[req].append(username)
                    print(f"Accepted friend request from {req}.")
                    pending.remove(req)
            self.friend_requests[username] = [req for req in pending if req not in accepted]
        self.save_data()

    def check_credentials(self, username, password):
        return self.accounts.get(username) == password

    def reset_password(self, username):
        if username not in self.accounts:
            print("No account detected.")
            return
        sq = self.security_questions[username]
        if not sq["question"]:
            print("No security question set for this account. Cannot reset password.")
            return
        print("Security question:", sq["question"])
        answer = input("Your answer: ")
        if answer.strip().lower() == sq["answer"].strip().lower():
            new_password = input("Enter new password: ")
            self.accounts[username] = new_password
            self.failed_attempts[username] = 0
            print("Password reset. Please login again.")
            self.save_data()
        else:
            print("Security answer incorrect. Cannot reset password.")

    def sign_up(self, username):
        if username in self.accounts:
            print("Username already exists.")
            return
        password = input("Enter new password: ")
        confirm = input("Confirm password: ")
        if password != confirm:
            print("Passwords do not match.")
            return
        usertype = input("Are you a student, parent, or teacher? (default: student): ").strip().lower()
        if usertype not in ["student", "parent", "teacher"]:
            usertype = "student"
        question = input("Set a security question (for password reset): ")
        answer = input("Set the answer: ")
        self.accounts[username] = password
        self.security_questions[username] = {"question": question, "answer": answer}
        self.user_type[username] = usertype
        self.ensure_user(username)
        print("Account created! Please login.")
        self.save_data()

    def loading_screen(self):
        print("Loading into app...")
        self.menu()

    def menu(self):
        while True:
            usertype = self.user_type.get(self.current_user, "student")
            options = [
                ("Study Timer", self.study_timer_menu),
                ("Flashcards", self.flashcards_menu),
                ("Data Planner", self.data_planner),
                ("Daily Challenges", self.daily_challenges_menu),
                ("Set Reminder", self.set_reminder),
                ("Stats", self.stats_menu),
                ("Group Challenges", self.group_challenges_menu),
                ("Study Materials (Upload/Highlight)", self.study_materials_menu),
                ("Set Push Notification", self.push_notification_menu),
            ]
            if usertype == "student":
                options.append(("View Teacher Assignments", self.view_teacher_assignments))
                options.append(("View Study Assignments", self.view_study_assignments))  # NEW
            if usertype == "parent":
                options.append(("Parental Controls", self.parent_menu))
            if usertype == "teacher":
                options.append(("Teacher Dashboard", self.teacher_menu))
            options.append(("Log out", None))
            print(f"\nWhat screen to go to? (You are a {usertype})")
            for idx, (label, _) in enumerate(options, 1):
                print(f"{idx}. {label}")
            choice = input("Choice: ").strip()
            try:
                choice_num = int(choice)
                if 1 <= choice_num <= len(options):
                    if options[choice_num - 1][1] is None:
                        print("Logging out...\n")
                        self.save_data()
                        self.current_user = None
                        return
                    else:
                        options[choice_num - 1][1]()
                else:
                    print("Invalid choice.")
            except ValueError:
                print("Invalid choice.")

    # NEW METHOD: Students can view their study assignments
    def view_study_assignments(self):
        assignments = self.study_assignments.get(self.current_user, [])
        if not assignments:
            print("No study assignments found.")
            return

        print("\n=== Your Study Assignments ===")
        for i, assignment in enumerate(assignments, 1):
            completed_time = assignment.get('completed_minutes', 0)
            remaining_time = assignment['total_minutes'] - completed_time
            status = "✅ COMPLETED" if assignment.get('completed', False) else "📝 IN PROGRESS"

            print(f"\n{i}. {assignment['subject']} - {status}")
            print(f"   Teacher: {assignment['teacher']}")
            print(f"   Total required: {assignment['total_minutes']} minutes")
            print(f"   Completed: {completed_time} minutes")
            print(f"   Remaining: {remaining_time} minutes")
            print(f"   Due: {assignment.get('due_date', 'No due date')}")
            print(f"   Instructions: {assignment.get('instructions', 'No additional instructions')}")

            # Show progress bar
            progress = (completed_time / assignment['total_minutes']) * 100
            progress_bar = "█" * int(progress // 5) + "░" * (20 - int(progress // 5))
            print(f"   Progress: [{progress_bar}] {progress:.1f}%")

        print("\nTip: Use the Study Timer to work on these assignments. Time will be automatically tracked!")
        input("\nPress Enter to continue...")

    def flashcards_menu(self):
        options = [
            ("Create Flashcard", self.create_flashcard),
            ("Study Flashcards", self.study_flashcards),
            ("Back", None)
        ]
        while True:
            print("\nFlashcards Menu")
            for idx, (label, _) in enumerate(options, 1):
                print(f"{idx}. {label}")
            choice = input("Choice: ").strip()
            try:
                choice_num = int(choice)
                if 1 <= choice_num <= len(options):
                    if options[choice_num - 1][1] is None:
                        return
                    else:
                        options[choice_num - 1][1]()
                else:
                    print("Invalid choice.")
            except ValueError:
                print("Invalid choice.")

    def daily_challenges_menu(self):
        options = [
            ("Generate New Challenge", self.generate_challenge),
            ("Answer Challenge", self.answer_challenge),
            ("Back", None)
        ]
        while True:
            print("\nDaily Challenges Menu")
            for idx, (label, _) in enumerate(options, 1):
                print(f"{idx}. {label}")
            choice = input("Choice: ").strip()
            try:
                choice_num = int(choice)
                if 1 <= choice_num <= len(options):
                    if options[choice_num - 1][1] is None:
                        return
                    else:
                        options[choice_num - 1][1]()
                else:
                    print("Invalid choice.")
            except ValueError:
                print("Invalid choice.")

    def parent_menu(self):
        options = [
            ("View linked child accounts", self.parent_view_children),
            ("Add child account", self.parent_add_child),
            ("Set daily study time limit for child", self.parent_set_limit),
            ("View child's statistics", self.parent_child_stats),
            ("View child's study time details", self.parent_view_study_time),  # NEW
            ("Back", None)
        ]
        while True:
            print("\n--- Parental Controls ---")
            for idx, (label, _) in enumerate(options, 1):
                print(f"{idx}. {label}")
            choice = input("Choice: ").strip()
            try:
                choice_num = int(choice)
                if 1 <= choice_num <= len(options):
                    if options[choice_num - 1][1] is None:
                        return
                    else:
                        options[choice_num - 1][1]()
                else:
                    print("Invalid choice.")
            except ValueError:
                print("Invalid choice.")

    def parent_view_children(self):
        print("Children:", ", ".join(self.child_accounts.get(self.current_user, [])))

    def parent_add_child(self):
        child = input("Enter child's username: ")
        if child in self.accounts:
            self.ensure_user(child)
            if self.user_type[child] == "student":
                if child not in self.child_accounts[self.current_user]:
                    self.child_accounts[self.current_user].append(child)
                print("Child linked.")
                self.save_data()
            else:
                print("No such student account.")
        else:
            print("No such student account.")

    def parent_set_limit(self):
        child = input("Enter child's username: ")
        try:
            limit = int(input("Set daily time limit in minutes: "))
            self.time_limits[child] = limit
            self.save_data()
            print("Limit set.")
        except:
            print("Invalid input.")

    def parent_child_stats(self):
        child = input("Enter child's username: ")
        if child in self.child_accounts.get(self.current_user, []):
            self.stats_menu(child)
        else:
            print("Not your child.")

    # NEW METHOD: Parents can view detailed study time for children
    def parent_view_study_time(self):
        children = self.child_accounts.get(self.current_user, [])
        if not children:
            print("No linked child accounts found.")
            return

        print("\nYour children:")
        for i, child in enumerate(children, 1):
            print(f"{i}. {child}")

        try:
            choice = int(input("Select child number: ")) - 1
            if 0 <= choice < len(children):
                child = children[choice]
                self.show_child_study_details(child)
            else:
                print("Invalid selection.")
        except ValueError:
            print("Invalid input.")

    # NEW METHOD: Show detailed study information for a specific child
    def show_child_study_details(self, child):
        print(f"\n=== Study Details for {child} ===")

        # Get study history - convert old format to new format if needed
        study_sessions = self.study_history.get(child, [])
        if not study_sessions:
            print("No study sessions recorded yet.")
            return

        # Convert old string format to new dict format if needed
        converted_sessions = []
        for session in study_sessions:
            if isinstance(session, str):
                # Old format: just timestamp string
                converted_sessions.append({
                    'timestamp': session,
                    'duration': 25,  # Default duration for old sessions
                    'type': 'Legacy Session',
                    'subject': 'General'
                })
            else:
                # New format: already a dict
                converted_sessions.append(session)

        # Calculate today's study time
        today = datetime.now().date()
        today_sessions = [s for s in converted_sessions if datetime.strptime(s['timestamp'], "%Y-%m-%d %H:%M").date() == today]
        today_minutes = sum(s.get('duration', 25) for s in today_sessions)

        # Calculate this week's study time
        week_start = today - timedelta(days=today.weekday())
        week_sessions = [s for s in converted_sessions if datetime.strptime(s['timestamp'], "%Y-%m-%d %H:%M").date() >= week_start]
        week_minutes = sum(s.get('duration', 25) for s in week_sessions)

        # Calculate total study time
        total_minutes = sum(s.get('duration', 25) for s in converted_sessions)

        print(f"📊 Study Time Summary:")
        print(f"   Today: {today_minutes} minutes ({today_minutes//60}h {today_minutes%60}m)")
        print(f"   This week: {week_minutes} minutes ({week_minutes//60}h {week_minutes%60}m)")
        print(f"   Total all time: {total_minutes} minutes ({total_minutes//60}h {total_minutes%60}m)")
        print(f"   Total sessions: {len(converted_sessions)}")

        # Show daily limit status
        daily_limit = self.time_limits.get(child, 1440)
        if daily_limit < 1440:  # Only show if a limit is set
            remaining_today = max(0, daily_limit - today_minutes)
            print(f"   Daily limit: {daily_limit} minutes")
            print(f"   Remaining today: {remaining_today} minutes")
            if remaining_today == 0:
                print("   ⚠️ Daily limit reached!")

        # Show study assignments progress
        assignments = self.study_assignments.get(child, [])
        active_assignments = [a for a in assignments if not a.get('completed', False)]
        if active_assignments:
            print(f"\n📚 Active Study Assignments ({len(active_assignments)}):")
            for assignment in active_assignments:
                completed = assignment.get('completed_minutes', 0)
                total = assignment['total_minutes']
                progress = (completed / total) * 100
                print(f"   • {assignment['subject']}: {completed}/{total} min ({progress:.1f}%)")

        # Show recent study sessions
        print(f"\n📝 Recent Study Sessions (Last 7):")
        recent_sessions = sorted(converted_sessions, key=lambda x: x['timestamp'], reverse=True)[:7]
        for session in recent_sessions:
            timestamp = session['timestamp']
            duration = session.get('duration', 25)
            session_type = session.get('type', 'General Study')
            subject = session.get('subject', 'N/A')
            print(f"   • {timestamp}: {duration} min - {session_type}")
            if subject != 'N/A' and subject != 'General':
                print(f"     Subject: {subject}")

        # Show study streak
        streak = self.calculate_study_streak(child)
        print(f"\n🔥 Current study streak: {streak} days")

        input("\nPress Enter to continue...")

    # NEW METHOD: Calculate study streak
    def calculate_study_streak(self, username):
        study_sessions = self.study_history.get(username, [])
        if not study_sessions:
            return 0

        today = datetime.now().date()
        streak = 0
        current_date = today

        # Get unique study dates
        study_dates = set()
        for session in study_sessions:
            if isinstance(session, str):
                # Old format
                session_date = datetime.strptime(session, "%Y-%m-%d %H:%M").date()
            else:
                # New format
                session_date = datetime.strptime(session['timestamp'], "%Y-%m-%d %H:%M").date()
            study_dates.add(session_date)

        # Check consecutive days
        while current_date in study_dates:
            streak += 1
            current_date -= timedelta(days=1)

        return streak

    def teacher_menu(self):
        options = [
            ("View students", self.teacher_view_students),
            ("Add student", self.teacher_add_student),
            ("Assign daily challenge to student", self.teacher_assign_challenge),
            ("Assign study time to student", self.teacher_assign_study_time),  # NEW
            ("View student statistics", self.teacher_view_student_stats),
            ("View student study assignments", self.teacher_view_assignments),  # NEW
            ("Back", None)
        ]
        while True:
            print("\n--- Teacher Dashboard ---")
            for idx, (label, _) in enumerate(options, 1):
                print(f"{idx}. {label}")
            choice = input("Choice: ").strip()
            try:
                choice_num = int(choice)
                if 1 <= choice_num <= len(options):
                    if options[choice_num - 1][1] is None:
                        return
                    else:
                        options[choice_num - 1][1]()
                else:
                    print("Invalid choice.")
            except ValueError:
                print("Invalid choice.")

    def teacher_view_students(self):
        print("Students:", ", ".join(self.teacher_students.get(self.current_user, [])))

    def teacher_add_student(self):
        stu = input("Enter student's username: ")
        if stu in self.accounts:
            self.ensure_user(stu)
            if self.user_type[stu] == "student":
                if stu not in self.teacher_students[self.current_user]:
                    self.teacher_students[self.current_user].append(stu)
                print("Student linked.")
                self.save_data()
            else:
                print("That user is not a student account.")
        else:
            print("No such student account.")

    def teacher_assign_challenge(self):
        stu = input("Enter student's username: ")
        if stu in self.teacher_students.get(self.current_user, []):
            q = input("Enter challenge question: ")
            a = input("Enter challenge answer: ")
            self.daily_challenges[stu].append({"question": q, "answer": a, "attempted": False})
            self.save_data()
            print("Challenge assigned.")
        else:
            print("Not your student.")

    # NEW METHOD: Teachers can assign study time to students
    def teacher_assign_study_time(self):
        students = self.teacher_students.get(self.current_user, [])
        if not students:
            print("No students linked to your account.")
            return

        print("\nYour students:")
        for i, student in enumerate(students, 1):
            print(f"{i}. {student}")

        try:
            choice = int(input("Select student number: ")) - 1
            if 0 <= choice < len(students):
                student = students[choice]
                self.create_study_assignment(student)
            else:
                print("Invalid selection.")
        except ValueError:
            print("Invalid input.")

    # NEW METHOD: Create study assignment
    def create_study_assignment(self, student):
        print(f"\n=== Creating Study Assignment for {student} ===")

        subject = input("Subject/Topic: ").strip()
        if not subject:
            print("Subject cannot be empty.")
            return

        try:
            total_minutes = int(input("Total study time required (in minutes): "))
            if total_minutes <= 0:
                print("Study time must be positive.")
                return
        except ValueError:
            print("Invalid time input.")
            return

        due_date = input("Due date (YYYY-MM-DD, optional): ").strip()
        if due_date:
            try:
                # Validate date format
                datetime.strptime(due_date, "%Y-%m-%d")
            except ValueError:
                print("Invalid date format. Assignment created without due date.")
                due_date = "No due date"
        else:
            due_date = "No due date"

        instructions = input("Additional instructions (optional): ").strip()
        if not instructions:
            instructions = "No additional instructions"

        bonus_points = 5  # Default bonus points for completing assignment
        try:
            custom_bonus = input(f"Bonus points for completion (default {bonus_points}): ").strip()
            if custom_bonus:
                bonus_points = int(custom_bonus)
        except ValueError:
            print("Invalid bonus points, using default.")

        # Create the assignment
        assignment = {
            'subject': subject,
            'total_minutes': total_minutes,
            'completed_minutes': 0,
            'completed': False,
            'teacher': self.current_user,
            'due_date': due_date,
            'instructions': instructions,
            'bonus_points': bonus_points,
            'assigned_date': datetime.now().strftime("%Y-%m-%d %H:%M")
        }

        if student not in self.study_assignments:
            self.study_assignments[student] = []

        self.study_assignments[student].append(assignment)
        self.save_data()

        print(f"\n✅ Study assignment created successfully!")
        print(f"Student: {student}")
        print(f"Subject: {subject}")
        print(f"Required time: {total_minutes} minutes")
        print(f"Due date: {due_date}")
        print(f"Bonus points: {bonus_points}")

    # NEW METHOD: Teachers can view all their assignments
    def teacher_view_assignments(self):
        all_assignments = []

        # Collect all assignments created by this teacher
        for student, assignments in self.study_assignments.items():
            for assignment in assignments:
                if assignment.get('teacher') == self.current_user:
                    assignment_info = assignment.copy()
                    assignment_info['student'] = student
                    all_assignments.append(assignment_info)

        if not all_assignments:
            print("No study assignments created yet.")
            return

        print(f"\n=== All Study Assignments by {self.current_user} ===")

        # Group by completion status
        active_assignments = [a for a in all_assignments if not a.get('completed', False)]
        completed_assignments = [a for a in all_assignments if a.get('completed', False)]

        if active_assignments:
            print(f"\n📝 Active Assignments ({len(active_assignments)}):")
            for assignment in active_assignments:
                completed_time = assignment.get('completed_minutes', 0)
                total_time = assignment['total_minutes']
                progress = (completed_time / total_time) * 100

                print(f"\n• Student: {assignment['student']}")
                print(f"  Subject: {assignment['subject']}")
                print(f"  Progress: {completed_time}/{total_time} min ({progress:.1f}%)")
                print(f"  Due: {assignment.get('due_date', 'No due date')}")

                # Progress bar
                progress_bar = "█" * int(progress // 5) + "░" * (20 - int(progress // 5))
                print(f"  [{progress_bar}]")

        if completed_assignments:
            print(f"\n✅ Completed Assignments ({len(completed_assignments)}):")
            for assignment in completed_assignments:
                print(f"• {assignment['student']} - {assignment['subject']} ({assignment['total_minutes']} min)")

        input("\nPress Enter to continue...")

    def teacher_view_student_stats(self):
        stu = input("Enter student's username: ")
        if stu in self.teacher_students.get(self.current_user, []):
            self.stats_menu(stu)
        else:
            print("Not your student.")

    def study_timer_menu(self):
        options = [
            ("Pomodoro (25m work/5m break)", self.pomodoro_timer),
            ("Custom Timer", self.custom_study_timer),
            ("Back", None)
        ]
        while True:
            print("\nStudy Timer Menu")
            for idx, (label, _) in enumerate(options, 1):
                print(f"{idx}. {label}")
            choice = input("Choice: ").strip()
            try:
                choice_num = int(choice)
                if 1 <= choice_num <= len(options):
                    if options[choice_num - 1][1] is None:
                        return
                    else:
                        options[choice_num - 1][1]()
                else:
                    print("Invalid choice.")
            except ValueError:
                print("Invalid choice.")

    def group_challenges_menu(self):
        options = [
            ("Create Challenge", self.group_create),
            ("Join Challenge", self.group_join),
            ("Add Points", self.group_add_points),
            ("View Leaderboard", self.group_leaderboard),
            ("Back", None)
        ]
        while True:
            print("\nGroup Challenges")
            for idx, (label, _) in enumerate(options, 1):
                print(f"{idx}. {label}")
            choice = input("Choice: ").strip()
            try:
                choice_num = int(choice)
                if 1 <= choice_num <= len(options):
                    if options[choice_num - 1][1] is None:
                        self.save_data()
                        return
                    else:
                        options[choice_num - 1][1]()
                else:
                    print("Invalid choice.")
            except ValueError:
                print("Invalid choice.")

    def group_create(self):
        name = input("Challenge name: ")
        if name in self.group_challenges:
            print("Challenge name taken.")
            return
        self.group_challenges[name] = {
            "participants": [self.current_user],
            "scores": {self.current_user: 0},
            "active": True
        }
        print("Challenge created and joined!")

    def group_join(self):
        name = input("Challenge to join: ")
        if name not in self.group_challenges or not self.group_challenges[name]["active"]:
            print("No such active challenge.")
            return
        if self.current_user not in self.group_challenges[name]["participants"]:
            self.group_challenges[name]["participants"].append(self.current_user)
            self.group_challenges[name]["scores"][self.current_user] = 0
            print(f"Joined {name}!")
        else:
            print("You are already in this challenge.")

    def group_add_points(self):
        name = input("Challenge name: ")
        if name not in self.group_challenges:
            print("No such challenge.")
            return
        pts = int(input("Points to add: "))
        self.group_challenges[name]["scores"][self.current_user] = self.group_challenges[name]["scores"].get(self.current_user, 0) + pts
        print(f"{pts} points added to your challenge score.")

    def group_leaderboard(self):
        name = input("Challenge name: ")
        if name not in self.group_challenges:
            print("No such challenge.")
            return
        print(f"Leaderboard for {name}:")
        scores = self.group_challenges[name]["scores"]
        for uname, pts in sorted(scores.items(), key=lambda x: x[1], reverse=True):
            print(f"{uname}: {pts}")

    def study_materials_menu(self):
        options = [
            ("Upload Material", self.study_materials_upload),
            ("View Materials & Highlight Key Info", self.study_materials_view),
            ("Back", None)
        ]
        while True:
            print("\nStudy Materials")
            for idx, (label, _) in enumerate(options, 1):
                print(f"{idx}. {label}")
            choice = input("Choice: ").strip()
            try:
                choice_num = int(choice)
                if 1 <= choice_num <= len(options):
                    if options[choice_num - 1][1] is None:
                        self.save_data()
                        return
                    else:
                        options[choice_num - 1][1]()
                else:
                    print("Invalid choice.")
            except ValueError:
                print("Invalid choice.")

    def study_materials_upload(self):
        fname = input("Filename (simulated, e.g. slide1.pdf): ")
        print("Paste or type the extracted text from your slide/worksheet below (end with a single line with just 'END'):")
        lines = []
        while True:
            line = input()
            if line.strip() == "END":
                break
            lines.append(line)
        text = "\n".join(lines)
        self.study_materials[self.current_user].append({"file": fname, "text": text, "key_info": []})
        print("Material uploaded.")

    def study_materials_view(self):
        mats = self.study_materials[self.current_user]
        if not mats:
            print("No materials uploaded.")
            return
        for idx, mat in enumerate(mats):
            print(f"\nMaterial {idx+1}: {mat['file']}")
            print("Extracted text:")
            print(mat['text'])
            print("Key info so far:", mat.get("key_info", []))
            if input("Highlight more key info? (y/n): ").lower() == "y":
                highlight = input("Paste or type key phrase to highlight: ")
                mat.setdefault("key_info", []).append(highlight)
        print("Updated key info.")

    def push_notification_menu(self):
        print("\nPush Notification (Simulated)")
        title = input("Notification title: ")
        body = input("Notification body: ")
        time_str = input("When? (YYYY-MM-DD HH:MM): ")
        try:
            notif_time = datetime.strptime(time_str, "%Y-%m-%d %H:%M")
        except ValueError:
            print("Invalid time format.")
            return
        self.notifications[self.current_user].append({
            "title": title,
            "body": body,
            "time": notif_time.strftime("%Y-%m-%d %H:%M")
        })
        print("Notification scheduled!")
        self.save_data()

    # --- Core methods ---
    def stats_menu(self, user=None):
        if user is None:
            user = self.current_user
        print(f"\n--- Statistics for {user} ---")

        # Calculate streak using new method
        streak = self.calculate_study_streak(user)
        print(f"Current study streak: {streak} days")

        # Get detailed study sessions - handle both old and new formats
        study_sessions = self.study_history.get(user, [])
        total_sessions = len(study_sessions)

        # Calculate total minutes - handle old string format and new dict format
        total_minutes = 0
        for session in study_sessions:
            if isinstance(session, str):
                # Old format: assume 25 minutes per session
                total_minutes += 25
            else:
                # New format: has duration field
                total_minutes += session.get('duration', 0)

        print(f"Study sessions: {total_sessions}")
        print(f"Total study time: {total_minutes} minutes ({total_minutes//60}h {total_minutes%60}m)")

        # Show today's and this week's study time
        today = datetime.now().date()
        week_start = today - timedelta(days=today.weekday())

        today_minutes = 0
        week_minutes = 0

        for session in study_sessions:
            if isinstance(session, str):
                session_date = datetime.strptime(session, "%Y-%m-%d %H:%M").date()
                session_duration = 25  # Default for old format
            else:
                session_date = datetime.strptime(session['timestamp'], "%Y-%m-%d %H:%M").date()
                session_duration = session.get('duration', 0)

            if session_date == today:
                today_minutes += session_duration
            if session_date >= week_start:
                week_minutes += session_duration

        print(f"Today's study time: {today_minutes} minutes")
        print(f"This week's study time: {week_minutes} minutes")

        # Show flashcard stats
        stats = self.flashcard_stats.get(user, {"correct": 0, "total": 0})
        print(f"Flashcard accuracy: {stats['correct']}/{stats['total']} correct "
              f"({(stats['correct']/stats['total']*100 if stats['total'] else 0):.1f}%)")

        print(f"Total points: {self.points.get(user,0)}")

        # Show study assignments if any
        assignments = self.study_assignments.get(user, [])
        if assignments:
            completed_assignments = sum(1 for a in assignments if a.get('completed', False))
            print(f"Study assignments: {completed_assignments}/{len(assignments)} completed")

        print("-----------------------------------")
        input("Press Enter to return to menu...")

    def create_flashcard(self):
        question = input("Enter question: ")
        answer = input("Enter answer: ")
        self.flashcards[self.current_user].append((question, answer))
        print("Flashcard created.")

    def study_flashcards(self):
        cards = self.flashcards[self.current_user]
        if not cards:
            print("No flashcards to study.")
            return
        for q, a in cards:
            print(f"Q: {q}")
            input("Press Enter to show answer...")
            print(f"A: {a}")
            answer = input("Your answer (type it): ")
            correct = answer.strip().lower() == a.strip().lower()
            self.flashcard_stats[self.current_user]['total'] += 1
            if correct:
                print("Correct!")
                self.flashcard_stats[self.current_user]['correct'] += 1
            else:
                print("Incorrect.")
            print(f"Current accuracy: {self.flashcard_stats[self.current_user]['correct']}/{self.flashcard_stats[self.current_user]['total']}")
        self.save_data()

    def data_planner(self):
        print("\nData Planner")
        date = input("Enter date to plan (YYYY-MM-DD): ")
        subject = input("Enter subject/task: ")
        self.calendar[self.current_user][date] = subject
        print(f"Planned '{subject}' for {date}.")
        today = input("Is this for today? (y/n): ").lower() == "y"
        if today:
            print(f"Reminder: Study '{subject}' today!")
            self.points[self.current_user] += 1
        self.leaderboard()

    def generate_challenge(self):
        q = input("Enter challenge question: ")
        a = input("Enter challenge answer: ")
        self.daily_challenges[self.current_user].append({"question": q, "answer": a, "attempted": False})
        print("Challenge generated.")

    def answer_challenge(self):
        challenges = [c for c in self.daily_challenges[self.current_user] if not c.get("attempted", False)]
        if not challenges:
            print("No available challenges.")
            return
        for c in challenges:
            print(f"Challenge: {c['question']}")
            answer = input("Your answer: ")
            if answer.strip().lower() == c["answer"].strip().lower():
                print("Correct!")
                self.points[self.current_user] += 1
                c["attempted"] = True
                print("You earned 1 point!")
            else:
                print("Incorrect. Please try again later.")
        self.leaderboard()

    # UPDATED METHOD: Enhanced grant study points with assignment tracking
    def grant_study_points(self, duration, session_type="General Study", subject=None):
        now = datetime.now()
        user = self.current_user
        limit = self.time_limits.get(user, 1440)
        today = now.date()

        # Calculate today's study time from detailed history
        study_sessions = self.study_history.get(user, [])
        today_minutes = 0
        for session in study_sessions:
            if isinstance(session, str):
                session_date = datetime.strptime(session, "%Y-%m-%d %H:%M").date()
                session_duration = 25  # Default for old format
            else:
                session_date = datetime.strptime(session['timestamp'], "%Y-%m-%d %H:%M").date()
                session_duration = session.get('duration', 0)

            if session_date == today:
                today_minutes += session_duration

        if today_minutes >= limit:
            print(f"You have reached your daily study time limit: {limit} minutes.")
            return

        # Check if this would exceed the limit
        if today_minutes + duration > limit:
            allowed_duration = limit - today_minutes
            print(f"Study time limited to {allowed_duration} minutes due to daily limit.")
            duration = allowed_duration
            if duration <= 0:
                return

        # Award points
        pts = max(1, duration // 25 * 2)
        self.points[user] += pts
        print(f"You earned {pts} points!")

        # Record detailed study session
        session_record = {
            'timestamp': now.strftime("%Y-%m-%d %H:%M"),
            'duration': duration,
            'type': session_type,
            'subject': subject
        }

        self.last_study_time[user] = now
        if user not in self.study_history:
            self.study_history[user] = []
        self.study_history[user].append(session_record)

        # Update study assignments if applicable
        self.update_study_assignments(user, duration, subject)

        self.save_data()

    # NEW METHOD: Update study assignment progress
    def update_study_assignments(self, user, duration, subject):
        assignments = self.study_assignments.get(user, [])
        updated_any = False

        for assignment in assignments:
            if assignment.get('completed', False):
                continue  # Skip completed assignments

            # If subject matches or no specific subject for the study session
            if subject is None or assignment['subject'].lower() == subject.lower():
                assignment['completed_minutes'] = assignment.get('completed_minutes', 0) + duration
                updated_any = True

                # Check if assignment is now complete
                if assignment['completed_minutes'] >= assignment['total_minutes']:
                    assignment['completed'] = True
                    bonus_points = assignment.get('bonus_points', 5)
                    self.points[user] += bonus_points
                    print(f"🎉 Assignment completed! '{assignment['subject']}' - Bonus {bonus_points} points!")
                else:
                    remaining = assignment['total_minutes'] - assignment['completed_minutes']
                    print(f"📚 Assignment progress updated: '{assignment['subject']}' - {remaining} minutes remaining")

                break  # Only update one assignment per study session

        if updated_any:
            self.save_data()

    # UPDATED METHOD: Enhanced pomodoro with assignment tracking
    def pomodoro_timer(self):
        work = self.pomodoro_config["work"]
        brk = self.pomodoro_config["break"]
        print(f"Pomodoro: {work} minutes work, {brk} minutes break.")

        # Ask for subject if student has active assignments
        subject = self.ask_for_subject_if_assignments()

        input("Press Enter to start work session...")
        self.run_timer(work * 60, "Work")
        input("Press Enter to start break session...")
        self.run_timer(brk * 60, "Break")
        self.grant_study_points(duration=work, session_type="Pomodoro", subject=subject)
        print("Pomodoro session complete! Points awarded.")
        self.leaderboard()

    # UPDATED METHOD: Enhanced custom timer with assignment tracking
    def custom_study_timer(self):
        try:
            mins = int(input("Enter study minutes: "))
        except ValueError:
            print("Invalid input.")
            return
        if mins <= 0:
            print("Minutes must be positive.")
            return

        # Ask for subject if student has active assignments
        subject = self.ask_for_subject_if_assignments()

        input("Press Enter to start timer...")
        self.run_timer(mins * 60, "Custom Study")
        self.grant_study_points(duration=mins, session_type="Custom Timer", subject=subject)
        print("Custom study session complete! Points awarded.")
        self.leaderboard()

    # NEW METHOD: Ask student which subject they're studying
    def ask_for_subject_if_assignments(self):
        assignments = self.study_assignments.get(self.current_user, [])
        active_assignments = [a for a in assignments if not a.get('completed', False)]

        if not active_assignments:
            return None

        print(f"\nYou have {len(active_assignments)} active study assignment(s):")
        for i, assignment in enumerate(active_assignments, 1):
            remaining = assignment['total_minutes'] - assignment.get('completed_minutes', 0)
            print(f"{i}. {assignment['subject']} ({remaining} min remaining)")

        print(f"{len(active_assignments) + 1}. General study (not for a specific assignment)")

        try:
            choice = int(input("What will you be studying? Enter number: ")) - 1
            if 0 <= choice < len(active_assignments):
                return active_assignments[choice]['subject']
            elif choice == len(active_assignments):
                return None
            else:
                print("Invalid choice, treating as general study.")
                return None
        except ValueError:
            print("Invalid input, treating as general study.")
            return None

    def run_timer(self, seconds, label):
        print(f"{label} timer started for {seconds // 60} minutes.")
        for i in range(seconds, 0, -1):
            if i % 60 == 0 or i == seconds or i <= 5:
                print(f"{i // 60}m {i % 60}s left...", end="\r")
            time.sleep(1)
        print("\nTimer done.")

    def set_reminder(self):
        user = self.current_user
        print("Set a reminder for your study session or challenge.")
        msg = input("Reminder text: ")
        time_str = input("When? (YYYY-MM-DD HH:MM, 24h) ")
        try:
            reminder_time = datetime.strptime(time_str, "%Y-%m-%d %H:%M")
        except ValueError:
            print("Invalid format.")
            return
        self.reminders[user].append({"msg": msg, "time": reminder_time.strftime("%Y-%m-%d %H:%M")})
        print("Reminder set.")
        self.save_data()

    def check_due_reminders(self):
        now = datetime.now()
        for user, rems in self.reminders.items():
            due = [r for r in rems if datetime.strptime(r['time'], "%Y-%m-%d %H:%M") <= now]
            for r in due:
                print(f"Reminder for {user}: {r['msg']} (Scheduled: {r['time']})")
            self.reminders[user] = [r for r in rems if r not in due]
        self.save_data()

    def leaderboard(self):
        print(f"\nLeaderboard - Your points: {self.points[self.current_user]}")
        friends_and_you = [self.current_user] + self.friends[self.current_user]
        leaderboard_list = [(uname, self.points.get(uname, 0)) for uname in friends_and_you]
        leaderboard_list = list({uname: pts for uname, pts in leaderboard_list}.items())
        leaderboard_list.sort(key=lambda tup: tup[1], reverse=True)
        print("Leaderboard (You and Friends):")
        for rank, (uname, pts) in enumerate(leaderboard_list, 1):
            you_mark = " (You)" if uname == self.current_user else ""
            print(f"{rank}. {uname}{you_mark}: {pts} points")
        if input("Add friend via code? (y/n): ").lower() == "y":
            friend = input("Enter friend's username: ")
            if friend in self.accounts and friend != self.current_user:
                if self.current_user not in self.friend_requests[friend] and self.current_user not in self.friends[friend]:
                    self.friend_requests[friend].append(self.current_user)
                    print(f"Friend request sent to {friend}.")
                elif self.current_user in self.friends[friend]:
                    print("You are already friends!")
                else:
                    print("Friend request already sent.")
            else:
                print("No such user.")
        if self.points[self.current_user] >= 10:
            self.show_rewards()

    def show_rewards(self):
        print("\nRewards available! Choose one:")
        print("1. Gift card\n2. Game prop\n3. Extra theme\n4. Pet\n5. Extra content\n6. Keep my points (no reward)")
        choice = input("Your reward: ")
        rewards_map = {
            "1": "Gift card",
            "2": "Game prop",
            "3": "Extra theme",
            "4": "Pet",
            "5": "Extra content",
            "6": "Keep points"
        }
        reward = rewards_map.get(choice, "Gift card")
        if choice == "6":
            print("You chose to keep your points. No points deducted and no reward received.")
        else:
            self.rewards[self.current_user].append(reward)
            self.points[self.current_user] -= 10
            print(f"You redeemed: {reward} (10 points used).")
        self.save_data()

    def view_teacher_assignments(self):
        challenges = [c for c in self.daily_challenges[self.current_user] if not c.get("attempted", False)]
        if not challenges:
            print("No teacher assignments or all completed!")
            return
        for idx, c in enumerate(challenges, 1):
            print(f"\nAssignment {idx}: {c['question']}")
            answer = input("Your answer: ")
            if answer.strip().lower() == c["answer"].strip().lower():
                print("Correct!")
                self.points[self.current_user] += 1
                c["attempted"] = True
                print("You earned 1 point!")
            else:
                print("Incorrect. Please try again later.")
        self.save_data()

    def check_due_notifications(self):
        now = datetime.now()
        for user, notifs in self.notifications.items():
            due = [n for n in notifs if datetime.strptime(n['time'], "%Y-%m-%d %H:%M") <= now]
            for n in due:
                print(f"\n[NOTIFICATION for {user}]: {n['title']} - {n['body']} (Scheduled: {n['time']})")
            self.notifications[user] = [n for n in notifs if n not in due]
        self.save_data()


if __name__ == "__main__":
    app = StudyApp()
    app.start_screen() 
